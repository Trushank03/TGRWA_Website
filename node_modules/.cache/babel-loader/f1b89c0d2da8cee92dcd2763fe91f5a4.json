{"ast":null,"code":"const {\n  defaultArgs,\n  baseOptions\n} = require('./config');\n\nconst parseArgs = require('./utils/parseArgs');\n\nconst {\n  defaultOptions,\n  getCreateFFmpegCore\n} = require('./node');\n\nconst {\n  version\n} = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = function () {\n  let _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  const {\n    log: optLog,\n    logger,\n    progress: optProgress,\n    ...options\n  } = { ...baseOptions,\n    ...defaultOptions,\n    ..._options\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let runReject = null;\n  let running = false;\n\n  let customLogger = () => {};\n\n  let logging = optLog;\n  let progress = optProgress;\n  let duration = 0;\n  let frames = 0;\n  let readFrames = false;\n  let ratio = 0;\n\n  const detectCompletion = message => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      runReject = null;\n      running = false;\n    }\n  };\n\n  const log = (type, message) => {\n    customLogger({\n      type,\n      message\n    });\n\n    if (logging) {\n      console.log(`[${type}] ${message}`);\n    }\n  };\n\n  const ts2sec = ts => {\n    const [h, m, s] = ts.split(':');\n    return parseFloat(h) * 60 * 60 + parseFloat(m) * 60 + parseFloat(s);\n  };\n\n  const parseProgress = (message, prog) => {\n    if (typeof message === 'string') {\n      if (message.startsWith('  Duration')) {\n        const ts = message.split(', ')[0].split(': ')[1];\n        const d = ts2sec(ts);\n        prog({\n          duration: d,\n          ratio\n        });\n\n        if (duration === 0 || duration > d) {\n          duration = d;\n          readFrames = true;\n        }\n      } else if (readFrames && message.startsWith('    Stream')) {\n        const match = message.match(/([\\d.]+) fps/);\n\n        if (match) {\n          const fps = parseFloat(match[1]);\n          frames = duration * fps;\n        } else {\n          frames = 0;\n        }\n\n        readFrames = false;\n      } else if (message.startsWith('frame') || message.startsWith('size')) {\n        const ts = message.split('time=')[1].split(' ')[0];\n        const t = ts2sec(ts);\n        const match = message.match(/frame=\\s*(\\d+)/);\n\n        if (frames && match) {\n          const f = parseFloat(match[1]);\n          ratio = Math.min(f / frames, 1);\n        } else {\n          ratio = t / duration;\n        }\n\n        prog({\n          ratio,\n          time: t\n        });\n      } else if (message.startsWith('video:')) {\n        prog({\n          ratio: 1\n        });\n        duration = 0;\n      }\n    }\n  };\n\n  const parseMessage = _ref => {\n    let {\n      type,\n      message\n    } = _ref;\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n\n\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: message => parseMessage({\n          type: 'fferr',\n          message\n        }),\n        print: message => parseMessage({\n          type: 'ffout',\n          message\n        }),\n\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' || typeof WorkerGlobalScope !== 'undefined') {\n            if (typeof wasmPath !== 'undefined' && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n\n            if (typeof workerPath !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n\n          return prefix + path;\n        }\n      });\n      ffmpeg = Core.cwrap(options.mainName || 'proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n  /*\n   * Determine whether the Core is loaded.\n   */\n\n\n  const isLoaded = () => Core !== null;\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n\n\n  const run = function () {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve, reject) => {\n        const args = [...defaultArgs, ..._args].filter(s => s.length !== 0);\n        runResolve = resolve;\n        runReject = reject;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n\n\n  const FS = function (method) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    log('info', `run FS.${method} ${args.map(arg => typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`).join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n\n      return ret;\n    }\n  };\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n\n\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      // if there's any pending runs, reject them\n      if (runReject) {\n        runReject('ffmpeg has exited');\n      }\n\n      running = false;\n\n      try {\n        Core.exit(1);\n      } catch (err) {\n        log(err.message);\n\n        if (runReject) {\n          runReject(err);\n        }\n      } finally {\n        Core = null;\n        ffmpeg = null;\n        runResolve = null;\n        runReject = null;\n      }\n    }\n  };\n\n  const setProgress = _progress => {\n    progress = _progress;\n  };\n\n  const setLogger = _logger => {\n    customLogger = _logger;\n  };\n\n  const setLogging = _logging => {\n    logging = _logging;\n  };\n\n  log('info', `use ffmpeg.wasm v${version}`);\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS\n  };\n};","map":null,"metadata":{},"sourceType":"script"}